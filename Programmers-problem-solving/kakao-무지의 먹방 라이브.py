def solution(food_times, k):
    if k >= sum(food_times):
        return -1

    sort_ft = sorted(food_times)
    food_count = len(food_times)
    current_laps = 0
    total_laps = 0
    total_time = 0
    for food_time in sort_ft:
        current_laps = food_time - total_laps
        total_time += current_laps * food_count
        if k < total_time:
            total_time -= current_laps * food_count
            break
        food_count -= 1
        total_laps = food_time

    if food_count == 0:
        return -1

    k -= total_time
    remain_count = k % food_count

    f = []
    for index, remain_food in enumerate(food_times):
        if total_laps < remain_food:
            f.append(index+1)

    result = f[remain_count]

    return result

def solution(food_times, k):
    if k >= sum(food_times):
        return -1

    low, high = 0, 1000000000
    laps, total_times, food_count = 0, 0, len(food_times)
    while low <= high:
        mid = (low + high) // 2
        times = food_count * mid
        for i in food_times:
            cnt = i - mid
            if cnt < 0:
                times += cnt
        if times <= k:
            laps, total_times = mid, times
            low = mid + 1
        else:
            high = mid - 1
    food_times = [i - laps for i in food_times]

    for i in range(food_count):
        if food_times[i] > 0 and total_times == k:
            return i+1
        else:
            if not food_times[i] <= 0:
                total_times += 1
    return -1


a = [4, 3, 5, 6, 2]
b = 7
print(solution(a,b))

# k초 후에 먹어야 할지를 출력한다. 없으면 -1을 출력한다.
# 그렇다면 총 음식시간이 k보다 작으면 어차피 -1이다. 첫 종료조건으로 적합할듯
# 순서대로 음식을 섭취해야 한다.
# 마지막까지 갔다면, 다시 처음 음식을 섭취한다.
# 다음 음식을 다 먹은 상태라면, 그 다음 음식을 섭취한다. ex) 1->2일때, 2를 다 섭취했다면 3으로
# 반복해서 확인하게 되면, 시간이 너무 오래걸린다..당장 최대 k와 food_times만 곱해도 알수있다.
# 그렇다면 단순 구현은 아닐거다...시뮬레이션 해보자..!
# 먹는 시간은 [2,4,3,1,5,8,6] k는 28초로 정한다.
# 한바퀴씩 돌려서, 마지막에 남는 음식이 뭔지 계산해본다.
# 리스트, 한 바퀴에 걸린시간, 총 남은 시간 순이다.
# [2,4,3,1,5,8,6] 0초, 28초
# [1,3,2,0,4,7,5] 7초 ,21초
# [0,2,1,0,3,6,4] 6초, 15초
# [0,1,0,0,2,5,3] 5초, 10초
# [0,0,0,0,1,4,2] 4초, 6초
# [0,0,0,0,0,3,1] 3초, 3초
# [0,0,0,0,0,2,0] 2초, 1초
# [0,0,0,0,0,1,0] 1초, 0초
# 하나가 없어지면 전체를 한번 도는데 1초씩 단축됨.
# 뭐가 먼저 없어지는지 체크 한 후, 초에서 전체 인덱스 개수만큼 빼준다??
# 가령 4번 음식이 1이므로, 1바퀴를 돌면 다 먹게된다. 일반 1바퀴를 빼고, k-7 = 21초
# 이제는 총 인덱스가 6개다. 여기서 최소를 구하면 또 1개이므로 21-6 = 15초
# 5개인데 또 1개가 최소다. 15-5 = 10초
# 4개인데 또 1개다...리스트를 잘못 잡았나??...10-4=6초
# 3개에 최소는 1, 6-3 = 3초
# 2개에 최소 1, 3-2 = 1초
# 마지막이 2이므로 2바퀴 돌아야하는데, k가 1밖에 남지 않았다.
# 최종적으로 k는 0이 되었다. 최종 리스트는 [0,0,0,0,0,1,0] 요렇게 나왔다.
# 네트워크 장애가 고쳐진 후에는 마지막 남은 음식인 6번 음식을 섭취하면 된다.
# 시뮬레이션을 쉬운 리스트로 한 것 같은데, 일단 맞는 내용이다.
# 두 가지 정보를 얻었다.
# 1.마지막 인덱스에 도착하는 시간이 몇초인지 알면, 남은 초로 다음 인덱스를 구할 수 있다.
# 2.최소인 인덱스*리스트 수 만큼 빼주면, 남은 초로 다음 인덱스를 구할 수 있다.
# 1번으로 풀면 마지막 인덱스에 도착할때 걸린 시간이 최대이면서 k보다 작아야 할 것 이다.
# 위같은 경우라면 28초가 최대이며, 마지막 인덱스에 7번째 도착할 때가 최대라는 얘기이다.
# 그렇다면 수의 가감없이 그냥 7바퀴를 돌았다고 가정을 해보자. 남은 수들은 어떻게 될까?
# [-5,-3,-4,-6,-2,1,-1] 이처럼 나오게 된다. 음수는 건너뛴 횟수를 의미한다.
# 그렇다면 이 음수를 모두 더한다면 총 건너뛴 횟수를 알 수 있다. 위같은 경우는 총 21번이다.
# 전체 7바퀴를 도는 동안 21번 건너뛰었으니 총 움직인 횟수(음식수*7바퀴)에서 빼줘본다.
# 49 - 21 = 28로 정확하게 나온다. 이미 시뮬레이션이 끝나서 알 수 있는 것 처럼 보인다.
# 몇바퀴인지만 알면 되니 반대로 탐색을 통해 몇 바퀴를 돌아야 최대 바퀴수인지를 찾으면 된다.
# 즉, 리스트에서 각 인덱스에 몇을 빼야 최대 시간이면서 k보다 작은 수 인지 알면 된다는 말이다.
# 리스트의 최대값보다 높은 바퀴 수를 돌면 안되고, 반대로 최소값보다 작은 바퀴 수도 안된다.
# 그렇다면 최소,최대값 사이에서 특정한 값을 구하는 문제가 된다는 뜻이다. -> 이분탐색을 사용한다.
# 이분탐색을 통해 총 몇바퀴 째에 우리가 원하는 값이 나오는지 찾아낸다.
# 몇바퀴인지 알아냈다면, 리스트를 구한 바퀴 수만큼의 수를 전부 빼준 리스트로 바꾼다.
# 그 후 리스트 전체를 한번 탐색하며, 남은 초로 어느 인덱스에서 멈추는지 찾아내면 끝이다.
# 위의 방식처럼 코드를 작성해 보겠다.
# 2번으로 풀면 매 바퀴마다 리스트 수만큼 총 시간에서 빼고, 최솟값을 제외하면 된다.
# 오름차순으로 정렬된 배열을 하나 만들어 최솟값->최댓값 순으로 정렬시킨다.
# 최솟값을 뽑아 최솟값x리스트 수 만큼의 시간을 k에서 빼준다.
# 최솟값이 빠졌으므로 현재 리스트의 맨 앞을 빼준다.
# 위 과정을 반복 하는데, 빼기전에 만약 k보다 최솟값x리스트가 더 길다면 반복문을 멈추고 나온다.
# 현재 k에서 남은 리스트 수만큼 mod해준다 -> 몇 번 후에 먹어야 될 음식이 있는지 확인
# food_times를 반복하면서 각 index의 값과 총 바퀴수를 비교해준다.
# 총 바퀴수보다 크다면, 현 index+1값을 결과 리스트에 넣어준다. -> 몇번째 음식이 남아 있는지 확인
# 어느 음식이 남아있는지 저장한 리스트에 mod 해준 값으로 위치 확인을 해준다.